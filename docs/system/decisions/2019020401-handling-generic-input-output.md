# Handling generic Input/Output


## Context

Currently we use a single View from the Presenter, to render the normal output of the use case, that is bound to the View interface in the general provider. However, we're not handling different views that might be needed, nor error messages, which are directly written to the STDERR of the application.

Regarding the former, we're not allowing the user to choose the output representation she prefers to get. Regarding the latter, if we're decoupling the presenter from the controller to support segregation between input and output devices, we cannot then just assume that the input device will also be able to support output, like we're doing now.


## Decision

### Segregation of input and output devices

We assume that a generic application can be connected to several different input and output devices: this means that input may come from different input devices (for example keyboard and mouse), and the output may go to different output devices (for example `STDOUT`, a GUI, and the filesystem). Of course this requires us to drop the assumption that all usual Web applications make, that the input device is the same as the output device (a Web browser, or maybe a Web/application server to be more precise).

One of the objectives of modern architectures is exactly allowing multiple different output devices to be used by the same application, and also from the same input device. To allow this, it's necessary that the controller is oblivious of the specific output device that will be used: for example, the controller shouldn't know if the output is going to a GUI, a CLI, a log, an audio speaker or a combination of these. 

### Presenters and views

The use case component defines just a presenter type, leaving us the freedom of injecting whatever actual presenter implementation we want. This way, we can use the presenter to represent a specific output model, which is characterized by the set of view fields and data type conversions it supports, or in other words, the kind of view model it will produce. For example, a "screen" view model might convert the application response to a certain set of fields of certain type, with the intent of having them being displayed to a screen, while a "print" view model might produce from the same application response a different set of fields, of different types, specialized for being sent to a printer.

Still, the same view model, representing a certain output model, can be rendered on the selected output device in different ways: a "screen" output model, containing fields belonging to a screen representation, might still be rendered as an HTML page, or as TXT file, or still as a graph. All these alternatives are represented by different views. This means that a specific presenter component, for example the "screen" presenter component, will define a "screen" view interface, that will then be implemented by multiple actual "screen" view instances, like HTML screen view, graph screen view, etc., one of which will then be selected and injected in the presenter, to be used for rendering.

On systems supporting complex view structures, for example a GUI application, we might want to use multiple widgets within the same view. For example, the application response might contain both a result value, and an error message, and the two should be rendered on different widgets (maybe because all error messages, regardless of the use case that's producing them, need to be displayed on the same widget, for example a popup message). In this case, we can still have a single view injected to the presenter, but that view would act as a proxy, delegating rendering to the two different widgets behind the scenes.

### Input definition

We borrow a definition of "input" from the REST standard. According to this definition, an input will be made of:
- a resource identifier (for example `/path/to/my/resource`, URI in the Web context)
- some input parameters (for example `?some[]=value&some[]=other`)
- a resource representation (for example `.html`, `.pdf`, etc.)

this means that:
- the identifier is used to pick a couple of controller and action, that needs to be called to perform the requested use case
- the parameters are just passed to the action when it's called
- the representation is related to the specific view that will be used to render the output generated by the use case's presenter; additionally, once a view is selected, it's presenter is also chosen, because a presenter might have multiple views, but a view only belongs to one presenter

### Using a router

The interesting problem that arises is that the view to be chosen is known at input time, because it's related to the representation: this may lead to think that it should be known by the controller. However, the controller should be independent from any choice regarding the output, including which representation is used.

A solution can be to introduce a *router* component, that takes an input, and chooses a combination of *controller*, *action* and *view* according to the given input. This is much like what happens with usual MVC Web framework, but generalized for any kind of adapter. This choice made by the router can be statically configured, since it does not depend on the user input.

The input part is quite easy, in that the router needs just to create the right controller object, and call the right action method on it, passing the right parameters. The output part is trickier though: since the controller is decoupled from the presenter, it doesn't return any output object that can be then handled by the router, rather it forwards the execution to the presenter object, in a way that isn't in control of the router. What the router can do, though, is to select the correct view to be used, and use the container to bind it to the generic view interface. This way, when the presenter will be built, the right view object will automatically be injected into it.

### Output devices

Up to now we've only talked about output representations, i.e. views, which can be selected by the user with its input request. But what about actual output devices? Again, in the usual case this is not a concern because the output device is the same as the input one, so we assume that everything will just be rendered in the same place, and that the concept of output representation has to do just with the graphic or formatting aspects of the output. However, when we allow multiple output devices to be used to communicate the output to the user, the question arises if we should let the user select which devices he prefers the output to be sent to. We cannot give the user complete control over the selection of output devices, because they might not be available in some situations, or there could be some other technical issue, but still we want the user to have some kind of influence over it.

A solution might be that the application provides different configurations of output devices, and the user will be able to choose one of those configurations: the configurations will be designed so that they can be used without any issue, and the user will still be able to make a choice. Each different configuration will then be represented by a different view: this way the concept of output representation ends up including also the specific configuration of output devices to be used, in addition to details regarding the format with which to render the output.  

For a console application, the input device is usually only the process created by the operating system, on which the application itself is running: the process contains the command line arguments that can be used to model the whole input (resource, parameters and representation). The most obvious output device in this case is again the process (so in this case the input device is the same as the output device as well), which has an exit status, a STDOUT and a STDERR, that can be used to convey output to the user. However, several other output devices can be used from the command line as well, like the filesystem. What we could do, then, is to provide a view to display the output to the STDOUT, and another one to display it to a file, leaving the console clean.

Additionally, we can notice that primary ports are mainly concerned with receiving inputs from devices, and performing related use cases in turn. It's not always the case that an output will be returned to the device, also because the device might not support any kind of output at all. There are many situations where the device will just provide an input, and then no output is produced, like in the case where the input just triggers some messages to be sent, or something to be written to a database, etc.: in this case the use case simply won't have any presenter injected, but just other secondary ports. It's also interesting to notice from this, that the presenter can be assimilated just to a normal secondary port.

### Main output and side output

A typical application can have many different kinds of output. One of these is used to talk back to the user that provided the input (in case it can receive outputs): we can call it *main output*, and it would be produced by the selected use case. The *side output* would be any other kind of output produced by the application, like logging, monitoring, etc., which is not directly related to the input, and usually does not need to be presented to the same user that produced the input. In general, however, the main output is the one produced by the use case on purpose, and passed to the presenter: this output might not necessarily be returned to the same device that provided the input.

The main output is produced only once per input, by the presenter of the use case, while the side output can be produced multiple times during the execution of a use case, and is not handled by the presenter: this means that the concepts of view and view model are only related to the main output, also because the side output does not usually need to be represented in multiple ways, since it's not requested by the user.

Since side output is not using a presenter, the way to handle it can be to use a message bus to send output to a non-specified recipient from the application layer: inside the adapter, then, one or more configured handlers will receive the messages, and output them with on the configured devices.

As a case study, we can consider the verbose output of a console application. At first, this may seem a case where some side output (info logs) need to be redirected to the main output (console STDOUT). What's really happening, though, is that the side output is being produced in a way that is completely unrelated to the presenter and views used by the main output: messages are sent containing the side output, and then in the adapter a new handler is configured to listen to these messages, and print them to the same output device used by the main output. This way we can print to the same output device, but keep the two kinds of output completely independent.

### Handling errors

Errors generated by domain or application services can be caught inside the use case, and passed back to the presenter within the response. Now, the problem is that the same presenter, which is connected with a single, specific view, should handle two different situations, success and error, that in general require two different views. For example, in a GUI application, the presenter for a widget that displays some value may receive an error response instead of a success response, but the error message contained in the response cannot be displayed in place of the value: it should be displayed by a different widget (for example an error popup); what we can do here is to allow a presenter to handle multiple views, of course depending on the needs of the specific presenter, for example a regular view and an error view: this way the same presenter can update the value on the regular widget if the response was successful, or it can display the error message in the proper view, if the response was not successful. On a Web application, for example, a presenter may be injected with the regular view, in addition to the 404 view, the 500 view, etc., and can choose one according to the actual response. This way we keep all the displaying logic in the testable presenter, and we keep all views as simple (and non-testable) as possible.

Regarding input errors, meaning errors related to wrong input, or input that would not pass validation, we don't want to throw errors from inside the controller, because we won't be able to send error messages to an output device, since the controller knows nothing about the output strategy. The solution here is to let the controller stick to its only responsibility, which is that of translating input data using adapter-specific format, into request data using application-specific format, and feed it to the application service. It will be the application service job to do input validation: this way we both avoid having to deal with errors in the controller, and keep all error handling in a single place. In some way, we can say that the use case interactor is taking the role that so-called "controllers" have in regular Web applications, meaning validating input, wiring proper services to produce an output, and send the output to the proper presenter/view. 

Finally, we should also mention programming or configuration errors happening in the adapter, thus before any application or business logic is triggered (or after, if considering the phase of handling the output from within the adapter). We can refer to these errors as "system errors", since they belong to the low-level infrastructure of the application. The first thing to say, is that we want to display as much of these errors as possible on the output device, to immediately inform the user that there's something going on, instead of silently write to a log file.

Since they're not generated from inside the use case, we cannot handle system errors with the currently selected adapter. Instead of introducing a "special case", where only in this case we break the rule that views should always be handled by presenter, and manually create the error view to display the error, what we can do is to reason in terms of the application. Even if these errors happen in the adapter, the application is well aware that all kinds of errors may happen, including system errors, because all applications have them; thus, we can introduce a new primary port, which we could call "system" for example, containing a use case to handle errors: of course this use case will have its own controller, presenter and views, so that we can handle system errors following the same protocol, displaying most of them to the user.

Here we should first talk about how this use case will be called: of course it won't be called by an external device, as we are used to think of them, but in this case the device calling it would be the application itself, for example through the router, having produced a proper input.

The second thing to talk about is views reusability. Of course we could run into the situation where we want to use the same view to display both application errors and system errors, so we need to share view objects among different use cases and even primary ports: this shouldn't be a problem since views are configured in the generic configuration of the adapters bundle, and from there all views are visible.

Finally, we should consider that the error handling use case of the system port might produce errors itself, and at that point there won't be anything left to catch and display them. For these we can just setup a global try/catch in the main module, which would just write some log files for example, or even let them bubble up and let the application crash, if we are confident that they are rare enough.

### Sloth machine views

Being a command-line application, the Sloth machine uses the process as the input device, and the process itself, in addition perhaps to the filesystem, as output devices. In particular, we want to use the exit status and the STDOUT and STDERR as main output devices. It's important, though, to highlight that these same devices can be used also to render output coming from the program that is being executed by the virtual machine, in addition to the virtual machine itself, and they can also be used to display side output, for example information messages in a verbose configuration. For this reason, we should constantly keep in mind where some output is coming from, and not only on which device it's displayed.

The first thing to do is clearly understand what's the output that the use case is supposed to provide: in our case the output comprises two elements:
- the exit status of the program execution
- the error message that might possibly have happend
- optionally, a flag to tell if the response is successful or not

it's important to underline that we want errors to be part of the output, because they're still significant for the application. Including errors in the response means that they can be handled by the presenter, and the views attached to it. Alternatively, we could have chosen to send the errors to some kind of side output, for example events, but in that case the decision of whether to display these errors or not would have been taken by the adapter, and not by the application. By sending errors with the response, we are clearly stating that we want errors to be displayed, as an application rule.

Then we should decide which representations we want to support, at the adapter level. Representations are organized in presenters and views, where presenters have the duty of selecting the proper subset of information, and how they are converted from application or domain data structures, and views have the duty of display this subset of information with different formats.

The *console presenter* represents console output, with exit status abiding by POSIX standard, and error messages available to be displayed. View model fields are:
- exit status as number less than 255
- error message as string
The views supported by the console presenter are:
- *integrated view*: used to run programs on the virtual machine, as if they were normal executables; this means that the program's exit status is returned as the application's own exit status, and the error message is printed to STDERR
- *clean view*: used to run programs on the virtual machine, but hiding the error message, so to keep the console clean; the exit status is still returned as the application's own exit status, but now the error message is written to a file; a possible use case of this is when the actual program is writing stuff to STDERR, and we don't want it to mix with errors written by the application (instead of the program)

The *textual presenter* represents a textual output, where all fields are available as verbose strings. View model fields are:
- exit status as verbose string, with no constraint, for example: `"Exit status: 321"`
- error message as string
The views supported by the textual presenter are:
- *verbose view*: used to gather all information on a centralized place, immediately visible; both the exit status and the error message are printed to STDOUT
- *archived view*: used to gather all information on a centralized place, but without clogging the console (notice that messages that are not part of the output, like system errors, might still be displayed to STDOUT or STDERR); both exit status and the error message are printed to a file

These views are also defining the representations that we can select in the input. For example, if the input selects the "verbose" representation, we already know both the view and the presenter that need to be instantiated, because even if a presenter can be related to multiple views, a single view can be related to only one presenter.  


## Status

Proposed


## Consequences

Everything regarding input and output for adapters is following a generic and reusable standard.

Different output representations and output devices are supported.

Input is actually completely decoupled from output.
