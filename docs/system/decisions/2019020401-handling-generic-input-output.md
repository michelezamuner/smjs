# Handling generic Input/Output


## Context

Currently we use a single View from the Presenter, to render the normal output of the use case, that is bound to the View interface in the general provider. However, we're not handling different views that might be needed, nor error messages, which are directly written to the STDERR of the application.

Regarding the former, we're not allowing the user to choose the output representation she prefers to get. Regarding the latter, if we're decoupling the presenter from the controller to support segregation between input and output devices, we cannot then just assume that the input device will also be able to support output, like we're doing now.


## Decision

### Segregation of input and output devices

We assume that a generic application can be connected to several different input and output devices: this means that input may come from different input devices (for example the keyboard and a mouse), and the output may need to go to different output devices (for example `STDOUT`, a GUI, and the filesystem). Of course this means to drop the assumption that all usual Web application make, that the input device is the same as the output device (a Web browser, or maybe a Web/application server to be more precise).

One of the objectives of modern architectures, is exactly that of allowing multiple different output devices to be used by the same application, and also from the same input device. To allow this, it's necessary that the controller is oblivious of the specific output device that will be used: for example, the controller shouldn't not if the output is going to a GUI, a CLI, a log, an audio speaker or a combination of these. 

Decoupling input devices from output devices can also enable asynchronous execution: the input may come from a Web device, but the output may be delayed to a later time, to avoid blocking incoming requests; in this situation it makes sense that the output is sent to a different device, for example an email that is sent after the long processing is complete, instead of blocking all requests to wat for the computation to finish, just to print the output back to the same Web device.

### Input definition

We borrow a definition of "input" from the REST standard. According to this definition, an input will be made of:
- a resource identifier (for example `/path/to/my/resource`, URI in the Web context)
- some input parameters (for example `?some[]=value&some[]=other`)
- a resource representation (for example `.html`, `.pdf`, etc.)

this means that:
- the identifier is used to pick a couple of controller and action, that needs to be called to perform the requested use case
- the parameters are just passed to the action when it's called
- the representation is related to the specific view that will be used to render the output generated by the use case's presenter

### Using a router

The interesting problem that arises is that the view to be chosen is known at input time, because it's related to the representation: this may lead to think that it should be known by the controller. However, the controller should be independent from any choice regarding the output, including which representation is used.

A solution can be to introduce a _router_ component, that takes an input, and chooses a combination of _controller_, _action_ and _view_ according to the given input. This is much like what happens with usual MVC Web framework, but generalized for any kind of adapter. This choice made by the router can be statically configured, since it does not depend on the user input.

The input part is quite easy, in that the router needs just to create the right controller object, and call the right action method on it, passing the right parameters. The output part is trickier though: since the controller is decoupled from the presenter, it doesn't return any output object that can be then handled by the router, rather it forwards the execution to the presenter object, in a way that isn't in control of the router. What the router can do, though, is to select the correct view to be used, and use the container to bind it to the generic view interface. This way, when the presenter will be built, the right view object will automatically be injected into it.

### Output devices

Up to now we've only talked about output representations, i.e. views, which can be selected by the user with its input request. But what about actual output devices? Again, in the usual case this is not a concern because the output device is the same as the input one, so we assume that everything will just be rendered in the same place, and that the concept of output representation has to do just with the graphic or formatting aspects of the output. However, when we allow multiple output devices to be used to communicate the output to the user, the question arises if we should let the user select which devices he prefers the output to be sent to. We cannot give the user complete control over the selection of output devices, because they might not be available in some situations, or there could be some other technical issue, but still we want the user to have some kind of influence over it.

A solution might be that the application provides different configurations of output devices, and the user will be able to choose one of those configurations: the configurations will be designed so that they can be used without any issue, and the user will still be able to make a choice. Each different configuration will then be represented by a different view: this way the concept of output representation ends up including also the specific configuration of output devices to be used, in addition to details regarding the format with which to render the output.  

For a console application, the input device is usually only the process created by the operating system, on which the application itself is running: the process contains the command line arguments that can be used to model the whole input (resource, parameters and representation). The most obvious output device in this case is again the process (so in this case the input device is the same as the output device as well), which has an exit status, a STDOUT and a STDERR, that can be used to convey output to the user. However, several other output devices can be used from the command line as well, like the filesystem. What we could do, then, is to provide a view to display the output to the STDOUT, and another one to display it to a file, leaving the console clean.

### Main output and side output

A typical application can have many different kinds of output. One of these is used to talk back to the user that provided the input: we can call it _main output_, and it would be produced by the selected use case. The _side output_ would be any other kind of output produced by the application, like logging, monitoring, etc., which is not directly related to the input, and usually does not need to be presented to the same user that produced the input.

The main output is produced only once per input, by the presenter of the use case, while the side output can be produced multiple times during the execution of a use case, and is not handled by the presenter: this means that the concepts of view and view model are only related to the main output, also because the side output does not usually need to be represented in multiple ways, since it's not requested by the user.

Since side output is not using a presenter, the way to handle it can be to use a message bus to send output to a non-specified recipient from the application layer: inside the adapter, then, one or more configured handlers will receive the messages, and output them with on the configured devices.

As a case study, we can consider the verbose output of a console application. At first, this may seem a case where some side output (info logs) need to be redirected to the main output (console STDOUT). What's really happening, though, is that the side output is being produced in a way that is completely unrelated to the presenter and views used by the main output: messages are sent containing the side output, and then in the adapter a new handler is configured to listen to these messages, and print them to the same output device used by the main output. This way we can print to the same output device, but keep the two kinds of output completely independent.

### Handling errors

Errors generated by domain or application services can be caught inside the use case, and rendered in the selected view. Regarding this, handling errors in the views might seem a bit strange if we compare it to what it's usually done in Web frameworks, where errors are handled by specific views according to the kind of error (404, 500, etc.): the choice of having separate views for specific errors turns out to actually be a specific case of the Web, where the errors that can be returned are always the same for all use cases, which are the HTTP errors. To understand how the generic case works, we can think of how a native or desktop application works: first of all, after each interaction the page is not totally re-rendered, like it happens with traditional Web applications, but just some changes happen to the same view; of course this is also what happens in case of errors, where perhaps a popup message will appear, or some widget will change, but anyway the error is handled within the same view, instead of a completely new view being loaded. Then, what we want to do is to leave our views with the same single `render` method, and instruct it to handle also error messages. Of course the view model will need to be able to also contain error messages, and a way to tell if an error has happened or not.

Another kind of errors are input ones, meaning errors related to wrong input, or input that would not pass validation. Regarding this kind of input, we don't want to throw errors from inside the controller, because we won't be able to send error messages to an output device, since the controller knows nothing about the output strategy. The solution here is to let the controller stick to its only responsibility, which is that of translating input data using adapter-specific format, into request data using application-specific format, and feed it to the application service. It will be the application service job to do input validation: this way we both avoid having to deal with errors in the controller, and keep all error handling in a single place.

Finally, we should also mention programming or configuration errors happening in the adapter, thus before any application or business logic is triggered (or after, if considering tha phase of handling the output in the adapter). Since these errors happen in the adapter, and are technical errors, they shouldn't be displayed in the view used to render the application or domain specific output, rather they should be sent to some other output device, for example a logger.

### Sloth machine views

Being a command-line application, the Sloth machine uses the process as the input device, and the process itself, in addition perhaps to the filesystem, as output devices. In particular, we want to use the exit status and the STDOUT and STDERR as main output devices. It's important, though, to highlight that these same devices can be used also to render output coming from the program that is being executed by the virtual machine, in addition to the virtual machine itself.

For example, I can be running a program on the virtual machine, and this program may be exiting with some exit status: here I may want to use the virtual machine's own exit status to carry the program exit status, meaning that the exit status of the virtual machine would be lost. In the same way, if the virtual machine uses STDOUT as one of its output devices, and the program being run on it is also writing to STDOUT, then outputs of both the virtual machine, and the program, will appear there, so it's important not to confuse the two.

What we can do, then, is using the different views to redirect the output to different devices, according to the user preference:
- _integrated view_: the exit status of the application (virtual machine) is used to contain the exit status of the program running on the virtual machine, and the exit status of the application itself is lost; running program and virtual machine use the same STDOUT and STDERR
- _clean view_: again the exit status of the virtual machine is used to carry the exit status of the program, but the virtual machine does not output to STDOUT and STDERR, but to different files, so that everything we see in the console comes from the program
- _verbose view_: STDOUT and STDERR are used by both the virtual machine and the program, the exit status of the program is written as text to STDOUT, and the process exits with the exit status of the virtual machine; additionally, application info messages are written to STDOUT in addition to any log files normally used


## Status

Proposed


## Consequences

Everything regarding input and output for adapters is following a generic and reusable standard.

Different output representations and output devices are supported.

Input is actually completely decoupled from output.
