# Handling generic Input/Output


## Context

Currently we use a single View from the Presenter, to render the normal output of the use case, that is bound to the View interface in the general provider. However, we're not handling different views that might be needed, nor error messages, which are directly written to the STDERR of the application.

Regarding the former, we're not allowing the user to choose the output representation she prefers to get. Regarding the latter, if we're decoupling the presenter from the controller to support segregation between input and output devices, we cannot then just assume that the input device will also be able to support output, like we're doing now.


## Decision

### Segregation of input and output devices

We assume that a generic application can be connected to several different input and output devices: this means that input may come from different input devices (for example keyboard and mouse), and the output may go to different output devices (for example `STDOUT`, a GUI, and the filesystem). Of course this requires us to drop the assumption that all usual Web applications make, that the input device is the same as the output device (a Web browser, or maybe a Web/application server to be more precise).

One of the objectives of modern architectures is exactly allowing multiple different output devices to be used by the same application, and also from the same input device. To allow this, it's necessary that the controller is oblivious of the specific output device that will be used: for example, the controller shouldn't know if the output is going to a GUI, a CLI, a log, an audio speaker or a combination of these. 

### Presenters and views

The use case component defines just a presenter type, leaving us the freedom of injecting whatever actual presenter implementation we want. This way, we can use the presenter to represent a specific output model, which is characterized by the set of view fields and data type conversions it supports, or in other words, the kind of view model it will produce. For example, a "screen" view model might convert the application response to a certain set of fields of certain type, with the intent of having them being displayed to a screen, while a "print" view model might produce from the same application response a different set of fields, of different types, specialized for being sent to a printer.

Still, the same view model, representing a certain output model, can be rendered on the selected output device in different ways: a "screen" output model, containing fields belonging to a screen representation, might still be rendered as an HTML page, or as TXT file, or still as a graph. All these alternatives are represented by different views. This means that a specific presenter component, for example the "screen" presenter component, will define a "screen" view interface, that will then be implemented by multiple actual "screen" view instances, like HTML screen view, graph screen view, etc., one of which will then be selected and injected in the presenter, to be used for rendering.

On systems supporting complex view structures, for example a GUI application, we might want to use multiple widgets within the same view. For example, the application response might contain both a result value, and an error message, and the two should be rendered on different widgets (maybe because all error messages, regardless of the use case that's producing them, need to be displayed on the same widget, for example a popup message). In this case, we can still have a single view injected to the presenter, but that view would act as a proxy, delegating rendering to the two different widgets behind the scenes.

### Input definition

We borrow a definition of "input" from the REST standard. According to this definition, an input will be made of:
- a resource identifier (for example `/path/to/my/resource`, URI in the Web context)
- some input parameters (for example `?some[]=value&some[]=other`)
- a resource representation (for example `.html`, `.pdf`, etc.)

this means that:
- the identifier is used to pick a couple of controller and action, that needs to be called to perform the requested use case
- the parameters are just passed to the action when it's called
- the representation is related to the specific view that will be used to render the output generated by the use case's presenter; additionally, once a view is selected, it's presenter is also chosen, because a presenter might have multiple views, but a view only belongs to one presenter

### Using a router

The interesting problem that arises is that the view to be chosen is known at input time, because it's related to the representation: this may lead to think that it should be known by the controller. However, the controller should be independent from any choice regarding the output, including which representation is used.

A solution can be to introduce a *router* component, that takes an input, and chooses a combination of *controller*, *action* and *view* according to the given input. This is much like what happens with usual MVC Web framework, but generalized for any kind of adapter. This choice made by the router can be statically configured, since it does not depend on the user input.

The input part is quite easy, in that the router needs just to create the right controller object, and call the right action method on it, passing the right parameters. The output part is trickier though: since the controller is decoupled from the presenter, it doesn't return any output object that can be then handled by the router, rather it forwards the execution to the presenter object, in a way that isn't in control of the router. What the router can do, though, is to select the correct view to be used, and use the container to bind it to the generic view interface. This way, when the presenter will be built, the right view object will automatically be injected into it.

### Output devices

Up to now we've only talked about output representations, i.e. views, which can be selected by the user with its input request. But what about actual output devices? Again, in the usual case this is not a concern because the output device is the same as the input one, so we assume that everything will just be rendered in the same place, and that the concept of output representation has to do just with the graphic or formatting aspects of the output. However, when we allow multiple output devices to be used to communicate the output to the user, the question arises if we should let the user select which devices he prefers the output to be sent to. We cannot give the user complete control over the selection of output devices, because they might not be available in some situations, or there could be some other technical issue, but still we want the user to have some kind of influence over it.

A solution might be that the application provides different configurations of output devices, and the user will be able to choose one of those configurations: the configurations will be designed so that they can be used without any issue, and the user will still be able to make a choice. Each different configuration will then be represented by a different view: this way the concept of output representation ends up including also the specific configuration of output devices to be used, in addition to details regarding the format with which to render the output.  

For a console application, the input device is usually only the process created by the operating system, on which the application itself is running: the process contains the command line arguments that can be used to model the whole input (resource, parameters and representation). The most obvious output device in this case is again the process (so in this case the input device is the same as the output device as well), which has an exit status, a STDOUT and a STDERR, that can be used to convey output to the user. However, several other output devices can be used from the command line as well, like the filesystem. What we could do, then, is to provide a view to display the output to the STDOUT, and another one to display it to a file, leaving the console clean.

Additionally, we can notice that primary ports are mainly concerned with receiving inputs from devices, and performing related use cases in turn. It's not always the case that an output will be returned to the device, also because the device might not support any kind of output at all. There are many situations where the device will just provide an input, and then no output is produced, like in the case where the input just triggers some messages to be sent, or something to be written to a database, etc.: in this case the use case simply won't have any presenter injected, but just other secondary ports. It's also interesting to notice from this, that the presenter can be assimilated just to a normal secondary port.

### Main output and side output

A typical application can have many different kinds of output. One of these is used to talk back to the user that provided the input (in case it can receive outputs): we can call it *main output*, and it would be produced by the selected use case. The *side output* would be any other kind of output produced by the application, like logging, monitoring, etc., which is not directly related to the input, and usually does not need to be presented to the same user that produced the input. In general, however, the main output is the one produced by the use case on purpose, and passed to the presenter: this output might not necessarily be returned to the same device that provided the input.

The main output is produced only once per input, by the presenter of the use case, while the side output can be produced multiple times during the execution of a use case, and is not handled by the presenter: this means that the concepts of view and view model are only related to the main output, also because the side output does not usually need to be represented in multiple ways, since it's not requested by the user.

Since side output is not using a presenter, the way to handle it can be to use a message bus to send output to a non-specified recipient from the application layer: inside the adapter, then, one or more configured handlers will receive the messages, and output them with on the configured devices.

As a case study, we can consider the verbose output of a console application. At first, this may seem a case where some side output (info logs) need to be redirected to the main output (console STDOUT). What's really happening, though, is that the side output is being produced in a way that is completely unrelated to the presenter and views used by the main output: messages are sent containing the side output, and then in the adapter a new handler is configured to listen to these messages, and print them to the same output device used by the main output. This way we can print to the same output device, but keep the two kinds of output completely independent.

### Handling errors

We can identify three broad categories of errors: application errors, input errors and system errors. Errors generated by domain or application services can be caught inside the use case, and passed back to the presenter in the response. Input errors are related to wrong input, or input that doesn't pass validation, and they are again checked inside the application interactors: they shouldn't be handled by controllers, because controllers have no way to select a specific output device to forward errors to, and additionally it's better if controllers stick to their single responsibility of translating data using adapter-specific format, int request data using application-specific format; on the other hand, we can say that the use case interactor is taking the role that so-called "controllers" have in traditional Web applications, meaning validating input, using proper services to produce an output, and send the output to the proper presenter/view. Finally, system errors are programming or configuration errors that may happen in the adapter-specific code, and that are generally caught during development, but which may still happen in production, and make the application crash: since these errors might happen outside of the application logic, they cannot be handled by the application service, like application and input errors, but still they should be caught and displayed on an output device to notify the user.

Regarding system errors, since they're not generated from inside the use case, we cannot handle them with the currently selected adapter. Instead of introducing a "special case", where only in this case we break the rule that views should always be handled by presenter, and manually create the error view to display the error, what we can do is to reason in terms of the application. Even if these errors happen in the adapter, the application is well aware that all kinds of errors may happen, including system errors, because all applications have them; thus, we can introduce a new primary port, which we could call "application" for example, whose actor would be the application itself, meaning that it should be called by other application modules, and it would contain a use case to handle errors: of course this use case will have its own controller, presenter and views, so that we can handle system errors following the same protocol, displaying most of them to the user. This "application" port could then be reused to handle additional cross-cutting concerns that pertain to multiple ports, and for which we don't want to duplicate the same solutions. In practical terms, what we'd do to use this port is letting errors bubble up to the main component, and from there create an input object targeted at the error handler controller, and send it to the router, exactly as any other input. What's tricky here is that the error handling use case might produce errors itself, and this might generate infinite loops because they'd be redirected again to the error handler itself, so we should be aware of this.

Regarding errors generated by domain or application services, they can be caught inside the use case, and passed back to the presenter within the response. Now, the problem is that the same presenter, which is connected with a single, specific view, should handle two different situations, success and error, that in general require two different views. For example, in a GUI application, the presenter for a widget that displays some value may receive an error response instead of a success response, but the error message contained in the response cannot be displayed in place of the value: it should be displayed by a different widget (for example an error popup); in this case we can't let the presenter use multiple views, because the presenter package cannot depend on the views package: it's the other way around, that's why the presenter defines a view interface.

Now, presenter/view is an implementation of the "humble object" pattern, meaning that normally we'd have a single view object, doing the work of both our presenter and view, but we prefer to separate the two to maximize testability: however, this means that in a traditional setup, the presenter would still be part of the UI, and as such would still be allowed to know, and possibly use, other widgets/presenters. The solution could then be to allow presenters to use other presenters, for example the error one. However, how does this fit with packages relationships? Presenters and views are packaged per port/actor, but one presenter package can extend another, for example to reuse presenters belonging to a different package; what we want to do, then, is to let a presenter know and reuse the error handler presenter defined in the application port, so that the same UI widget will be used to display all errors: from a package perspective this is fine, because we're only letting UI packages (presenters/view) know each other.

However, what request object should be passed to the reused error presenter, since it should implement the request defined in the use case? We don't want the regular presenter package to depend on the error handling use case too, because it doesn't make sense: what we can do is define an intermediate "shared" presenter, which doesn't depend on the application port, but does all the presentation work, and then both the regular presenter, and the error handling presenter will reuse that shared presenter. The shared presenter will define a response object, which does not implement the application response, to be used by the regular presenter (preventing it to be bound to the application port), and the error handling presenter would just define a new response object, abiding by the application port this time, but reusing the shared response object.

### Communicating with the system

All processes, and thus all runtime environments, always have some output available, namely STDOUT and STDERR: this may lead us to think that all applications always have a main output available: however, the fact that processes always have an output is a technical detail, which is irrelevant for the application logic.

For example, we can have an application that listens to input coming from a sensor, and then activates an actuator in response: in this case not only there is no main output, but there is no output whatsoever...there's only a primary port (sensor) and a secondary port (actuator). Of course we would still want logging to happen: for this we should add another secondary port to send messages, to which a message bus adapter will be attached; then the message bus can be configured with any number of handlers, including a logging one.

This model, however, doesn't take into account another important aspect, which is the fact that the application must be running on a process: we are handling communication with the sensor, with the actuator, with the event bus, but not with the operating system. This is, of course, a device that is always present in all applications, but which should nevertheless be taken in consideration. For this reason, we need a "system" or "core/kernel" port, to which a process adapter should be attached, handling input and output of the runtime process.

Actually, this port should not be the same in all applications, because in many applications the main port communicates directly through the process: this is the case of all command-line applications for example. For this reason, we only need the system port if communicating with the system is related to a special intent, other than the main communication intent of the application, like in the case of the sensor/actuator system, where the main communication intent is getting signals from the sensor, while reporting to the runtime process is just a secondary necessity.

When a device doesn't support any output facility, of course its adapter won't be concerned with handling output as well, meaning that it will only provide a controller: this is one of the cases where it's clear that the controller shouldn't have any output responsibility, in this case because it also cannot have it, since it doesn't know where the output will go, or even if there will be any output at all.

### Sloth machine views

Being a command-line application, the Sloth machine uses the process as the input device, and the process itself, in addition perhaps to the filesystem, as output devices. In particular, we want to use the exit status and the STDOUT and STDERR as main output devices. It's important, though, to highlight that these same devices can be used also to render output coming from the program that is being executed by the virtual machine, in addition to the virtual machine itself, and they can also be used to display side output, for example information messages in a verbose configuration. For this reason, we should constantly keep in mind where some output is coming from, and not only on which device it's displayed.

The first thing to do is clearly understand what's the output that the use case is supposed to provide: in our case the output comprises two elements:
- the exit status of the program execution
- the error message that might possibly have happend
- optionally, a flag to tell if the response is successful or not

it's important to underline that we want errors to be part of the output, because they're still significant for the application. Including errors in the response means that they can be handled by the presenter, and the views attached to it. Alternatively, we could have chosen to send the errors to some kind of side output, for example events, but in that case the decision of whether to display these errors or not would have been taken by the adapter, and not by the application. By sending errors with the response, we are clearly stating that we want errors to be displayed, as an application rule.

Then we should decide which representations we want to support, at the adapter level. Representations are organized in presenters and views, where presenters have the duty of selecting the proper subset of information, and how they are converted from application or domain data structures, and views have the duty of display this subset of information with different formats.

The *console presenter* represents console output, with exit status abiding by POSIX standard, and error messages available to be displayed. View model fields are:
- exit status as number less than 255
- error message as string
The views supported by the console presenter are:
- *integrated view*: used to run programs on the virtual machine, as if they were normal executables; this means that the program's exit status is returned as the application's own exit status, and the error message is printed to STDERR
- *clean view*: used to run programs on the virtual machine, but hiding the error message, so to keep the console clean; the exit status is still returned as the application's own exit status, but now the error message is written to a file; a possible use case of this is when the actual program is writing stuff to STDERR, and we don't want it to mix with errors written by the application (instead of the program)

The *textual presenter* represents a textual output, where all fields are available as verbose strings. View model fields are:
- exit status as verbose string, with no constraint, for example: `"Exit status: 321"`
- error message as string
The views supported by the textual presenter are:
- *verbose view*: used to gather all information on a centralized place, immediately visible; both the exit status and the error message are printed to STDOUT
- *archived view*: used to gather all information on a centralized place, but without clogging the console (notice that messages that are not part of the output, like system errors, might still be displayed to STDOUT or STDERR); both exit status and the error message are printed to a file

These views are also defining the representations that we can select in the input. For example, if the input selects the "verbose" representation, we already know both the view and the presenter that need to be instantiated, because even if a presenter can be related to multiple views, a single view can be related to only one presenter.  


## Status

Proposed


## Consequences

Everything regarding input and output for adapters is following a generic and reusable standard.

Different output representations and output devices are supported.

Input is actually completely decoupled from output.
